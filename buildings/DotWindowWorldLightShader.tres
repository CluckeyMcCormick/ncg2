[gd_resource type="Shader" format=2]

[resource]
code = "
// (c) 2022 Nicolas McCormick Fredrickson
// This code is licensed under the MIT license (see LICENSE.txt for details)

shader_type spatial;

render_mode unshaded, depth_draw_alpha_prepass;

// Color of the building
uniform vec4 BuildingColor : hint_color;

// Red Dot replacement color and light mixture scalar
uniform vec4 RedDotColor : hint_color;
uniform float RedDotLightMix : hint_range(0, 1);
// Green Dot
uniform vec4 GreenDotColor : hint_color;
uniform float GreenDotLightMix : hint_range(0, 1);
// Blue Dot
uniform vec4 BlueDotColor : hint_color;
uniform float BlueDotLightMix : hint_range(0, 1);
// The actual texture we'll be using to create the building
uniform sampler2D DotTexture;
// Sometimes, with window textures that have gradual gradients, we'll see weird
// color \"rings\" around the windows/dots. This is particularly noticeable when
// you remove alpha-ing out the building. The solution is to round the texture's
// alpha to one-or-zero - however, this results in a jagged look. Ergo, we leave
// it as a uniform. 
uniform float window_border_correction : hint_range(0, 1);

// The color of Light One
uniform vec4 LightOneColor : hint_color;
// The texture we'll be using to determine the light's relative power.
uniform sampler2D LightOnePowerTexture;
// The color of Light Two
uniform vec4 LightTwoColor : hint_color;
// The texture we'll be using to determine the light's relative power.
uniform sampler2D LightTwoPowerTexture;
// The color of Light Two
uniform vec4 LightThreeColor : hint_color;
// The texture we'll be using to determine the light's relative power.
uniform sampler2D LightThreePowerTexture;
// The color of Light Two
uniform vec4 LightFourColor : hint_color;
// The texture we'll be using to determine the light's relative power.
uniform sampler2D LightFourPowerTexture;
// I've found that the noise textures we use for lights don't have enough
// contrast for my taste. To get around that, we'll put each of the light
// textures through the adjust_contrast function (see below). What's the
// contrast factor we feed in to that function?
uniform float light_contrast_factor : hint_range(0, 10);

// Adjust's the \"contrast curve\" of a given color. To be honest I don't
// understand the math at play here, but it works!
vec3 adjust_contrast( in vec3 color, in float new_contrast) {
    // This was actually based on shader code from Stack Overflow, provided by
    // one Walt Ritscher:
    // https://stackoverflow.com/questions/944713/help-with-pixel-shader-effect-for-brightness-and-contrast
    return ((color - 0.5) * max(new_contrast, 0)) + 0.5;
}

void fragment(){
    // Grab the RGBA from the window dot texture
    vec4 window_texture = texture(DotTexture, UV.xy);
    // Devolve the vector into individual colors
    float win_r = window_texture.r;
    float win_g = window_texture.g;
    float win_b = window_texture.b;
    float win_a = window_texture.a;
    
    // Grab the different light colors from the appropriate light noise textures
    vec3 light_one_power = texture(LightOnePowerTexture, UV2.xy).rgb;
    vec3 light_two_power = texture(LightTwoPowerTexture, UV2.xy).rgb;
    vec3 light_three_power = texture(LightThreePowerTexture, UV2.xy).rgb;
    vec3 light_four_power = texture(LightFourPowerTexture, UV2.xy).rgb;
    
    //
    // Step 1: Determine window color, alpha, and mix factors for this fragment
    //    
    // Round the alpha according to our correction factor.
    win_a = mix(win_a, round(win_a), window_border_correction);
    
    // Instead of using if-else checks to replace the red-green-blue of the
    // window texture with our designated replacements, we'll use this mix
    // monstrosity. The red, green, and blue of the texture will be used as the
    // mix scalars. As long as the colors are pure, this will replace the dots
    // appropriately with no issues!
    vec3 color_mix = mix(mix(mix(
                // Mix between black and whatever our red color is, using the
                // \"redness\" as a scalar.
                vec3(0, 0, 0), RedDotColor.rgb, win_r
            // Mix between the above result and the green color, using the
            // \"greeness\" as a scalar
            ), GreenDotColor.rgb, win_g
        // Mix between the above result and the blue color, using the \"blueness\"
        // as a scalar
        ), BlueDotColor.rgb, win_b
    );

    // This is the same exact thing as above, but with alpha instead of RGB.
    float alpha_mix = mix(mix(mix(
                0.0, RedDotColor.a, win_r
            ), GreenDotColor.a, win_g
        ), BlueDotColor.a, win_b
    );
    
    //
    // Step 2: Determine light colors
    //
    // Adjust the contrast for each light color
    light_one_power = adjust_contrast(light_one_power, light_contrast_factor);
    light_two_power = adjust_contrast(light_two_power, light_contrast_factor);
    light_three_power = adjust_contrast(light_three_power, light_contrast_factor);
    light_four_power = adjust_contrast(light_four_power, light_contrast_factor);
    
    vec3 building_mix = mix(mix(mix(mix(
                    BuildingColor.rgb, LightOneColor.rgb, light_one_power
                // Mix between black and whatever our red color is, using the
                // \"redness\" as a scalar.
                ), LightTwoColor.rgb, light_two_power
            // Mix between the above result and the green color, using the
            // \"greeness\" as a scalar
            ), LightThreeColor.rgb, light_three_power
        // Mix between the above result and the blue color, using the \"blueness\"
        // as a scalar
        ), LightFourColor.rgb, light_four_power
    );
    
    // Just pass the building color and alpha straight through
    ALBEDO = mix(building_mix, color_mix, win_a);
    ALPHA = mix(BuildingColor.a, alpha_mix, win_a);
}"
